#!/usr/bin/env bash
set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${GREEN}=== YubiKey GPG Setup ===${NC}\n"

# Check prerequisites
command -v gpg >/dev/null || {
	echo -e "${RED}gpg not found${NC}"
	exit 1
}
command -v ykman >/dev/null || {
	echo -e "${RED}ykman not found${NC}"
	exit 1
}

# Verify YubiKey is connected
if ! ykman info &>/dev/null; then
	echo -e "${RED}No YubiKey detected. Please insert your YubiKey.${NC}"
	exit 1
fi

echo -e "${GREEN}YubiKey detected:${NC}"
ykman info | head -5

# Check if keys already exist on card
KEYS_EXIST=false
if gpg --card-status 2>/dev/null | grep -q "Signature key.*\[none\]"; then
	echo -e "\n${GREEN}No existing keys on YubiKey - ready to generate${NC}"
else
	KEYS_EXIST=true
	echo -e "\n${GREEN}GPG keys already exist on YubiKey${NC}"
	read -p "Reset and generate new keys? (y/N) " -n 1 -r
	echo
	if [[ $REPLY =~ ^[Yy]$ ]]; then
		echo -e "${YELLOW}Warning: This will permanently delete GPG keys and reset PINs.${NC}"
		echo -e "${GREEN}Other YubiKey features (FIDO2, OTP, PIV) are not affected.${NC}"
		read -p "Are you sure? (y/N) " -n 1 -r
		echo
		if [[ $REPLY =~ ^[Yy]$ ]]; then
			# Get the key ID currently on the YubiKey before reset
			OLD_KEY_ID=$(gpg --card-status 2>/dev/null | grep "Signature key" | awk '{gsub(/ /,""); print substr($NF,length($NF)-15)}')

			echo -e "${YELLOW}Resetting OpenPGP applet...${NC}"
			ykman openpgp reset --force
			echo -e "${GREEN}Reset complete. PINs restored to defaults.${NC}"

			# Remove old YubiKey key from GPG keyring
			if [[ -n "$OLD_KEY_ID" ]]; then
				echo -e "${YELLOW}Cleaning up old key ($OLD_KEY_ID) from GPG keyring...${NC}"
				gpg --batch --yes --delete-secret-keys "$OLD_KEY_ID" 2>/dev/null || true
				gpg --batch --yes --delete-keys "$OLD_KEY_ID" 2>/dev/null || true
				echo -e "${GREEN}Old key removed${NC}"
			fi

			KEYS_EXIST=false
		fi
	fi
fi

# Change PINs using ykman
echo -e "\n${GREEN}=== Step 1: Change PINs ===${NC}"
read -p "Change your PIN? (default: 123456) (y/N) " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
	ykman openpgp access change-pin
fi

read -p "Change your Admin PIN? (default: 12345678) (y/N) " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
	ykman openpgp access change-admin-pin
fi

# Generate key using GPG (this part requires gpg)
echo -e "\n${GREEN}=== Step 2: Generate GPG Key ===${NC}"
if ! gpg --card-status 2>/dev/null | grep -q "Signature key.*\[none\]"; then
	echo -e "${GREEN}GPG key already exists on YubiKey - skipping generation${NC}"
else
	echo -e "${YELLOW}Launching gpg --card-edit for key generation...${NC}"
	echo -e "Commands to run inside gpg:"
	echo -e "  1. admin"
	echo -e "  2. generate"
	echo -e "  3. Answer 'n' for off-card backup"
	echo -e "  4. Enter expiry: 0 = never, 2y = 2 years, etc."
	echo -e "  5. Enter name: <your-name>"
	echo -e "  6. Enter email: <your-email>"
	echo -e "  7. quit\n"

	read -p "Press Enter to launch gpg --card-edit..." -r
	gpg --card-edit
fi

# Set touch policy (only after keys exist)
echo -e "\n${GREEN}=== Step 3: Configure Touch Policy ===${NC}"
if gpg --card-status 2>/dev/null | grep -q "Signature key.*\[none\]"; then
	echo -e "${YELLOW}No keys on YubiKey yet - skipping touch policy${NC}"
else
	# Check current touch policy
	CURRENT_TOUCH=$(ykman openpgp info 2>/dev/null | grep -i "touch" || true)
	if echo "$CURRENT_TOUCH" | grep -qi "on"; then
		echo -e "${GREEN}Touch policy already enabled${NC}"
	else
		read -p "Enable touch policy for SIG (signing)? (Y/n) " -n 1 -r
		echo
		if [[ ! $REPLY =~ ^[Nn]$ ]]; then
			ykman openpgp keys set-touch sig on
			echo -e "${GREEN}SIG touch policy enabled${NC}"
		fi

		read -p "Enable touch policy for AUT (authentication)? (y/N) " -n 1 -r
		echo
		if [[ $REPLY =~ ^[Yy]$ ]]; then
			ykman openpgp keys set-touch aut on
			echo -e "${GREEN}AUT touch policy enabled${NC}"
		fi

		read -p "Enable touch policy for ENC (encryption)? (y/N) " -n 1 -r
		echo
		if [[ $REPLY =~ ^[Yy]$ ]]; then
			ykman openpgp keys set-touch enc on
			echo -e "${GREEN}ENC touch policy enabled${NC}"
		fi
	fi
fi

# Export public key
echo -e "\n${GREEN}=== Step 4: Export Public Key ===${NC}"
KEY_ID=$(gpg --list-secret-keys --keyid-format=long 2>/dev/null | awk -F'[/ ]' '/^sec/ {for(i=1;i<=NF;i++) if($i ~ /^[A-F0-9]{16}$/) print $i}' | head -1)

if [[ -z "$KEY_ID" ]]; then
	echo -e "${YELLOW}No key ID detected - skipping export${NC}"
elif [[ -f "$HOME/gpg-public-key-${KEY_ID}.asc" ]]; then
	echo -e "${GREEN}Public key already exported to: $HOME/gpg-public-key-${KEY_ID}.asc${NC}"
else
	PUB_KEY_FILE="$HOME/gpg-public-key-${KEY_ID}.asc"
	gpg --armor --export "$KEY_ID" >"$PUB_KEY_FILE"
	echo -e "Public key saved to: ${GREEN}${PUB_KEY_FILE}${NC}"
	echo -e "Add this to GitHub/GitLab for verified commits."
fi

# GPG agent config
echo -e "\n${GREEN}=== Step 5: GPG Agent Config ===${NC}"
GPG_AGENT_CONF="$HOME/.gnupg/gpg-agent.conf"
mkdir -p "$HOME/.gnupg"

AGENT_UPDATED=false

# Check and add default-cache-ttl if missing
if ! grep -q "^default-cache-ttl" "$GPG_AGENT_CONF" 2>/dev/null; then
	read -p "Add recommended gpg-agent.conf settings? (Y/n) " -n 1 -r
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]; then
		echo "default-cache-ttl 600" >>"$GPG_AGENT_CONF"
		AGENT_UPDATED=true
	fi
fi

# Check and add max-cache-ttl if missing
if ! grep -q "^max-cache-ttl" "$GPG_AGENT_CONF" 2>/dev/null; then
	echo "max-cache-ttl 7200" >>"$GPG_AGENT_CONF"
	AGENT_UPDATED=true
fi

# macOS specific: add pinentry-mac if missing
if [[ "$OSTYPE" == "darwin"* ]] && command -v pinentry-mac &>/dev/null; then
	if ! grep -q "^pinentry-program" "$GPG_AGENT_CONF" 2>/dev/null; then
		echo "pinentry-program $(which pinentry-mac)" >>"$GPG_AGENT_CONF"
		AGENT_UPDATED=true
	fi
fi

if [[ "$AGENT_UPDATED" == true ]]; then
	gpgconf --kill gpg-agent
	echo -e "${GREEN}gpg-agent.conf updated${NC}"
else
	echo -e "${GREEN}gpg-agent.conf already configured${NC}"
fi

echo -e "\n${GREEN}=== Setup Complete ===${NC}"
echo -e "Your key ID: ${GREEN}${KEY_ID:-unknown}${NC}"
echo -e "\nTest signing with:"
echo -e "  echo 'test' | gpg --clearsign"
echo -e "\nTo enable commit signing for a repo, run:"
echo -e "  ./configure-signing.sh"
